/*  xfilter2dkernel.c - The simplest kernel module.

* Copyright (C) 2013 - 2016 Xilinx, Inc
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/
#include <linux/dev_printk.h>
#include <linux/dma-direction.h>
#include <linux/dma-mapping.h>
#include <linux/interrupt.h>
#include <linux/io.h>
#include <linux/miscdevice.h>
#include <linux/module.h>
#include <linux/printk.h>
#include <linux/slab.h>
#include <linux/types.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>

#include "asm-generic/io.h"
#include "coefficients.h"
#include "linux/uaccess.h"
#include "xfilter2dkernel_hw.h"

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Xilinx Inc.");
MODULE_DESCRIPTION("xfilter2dkernel - loadable module template generated by "
                   "petalinux-create -t modules");

#define DRIVER_NAME "xfilter2dkernel"

/******************************************************************************/

#define def_op_reg16(field)                                                   \
    u16 GET_##field(void *base)                                               \
    {                                                                         \
        return ioread16(base + XFILTER2DKERNEL_CONTROL_ADDR_##field##_DATA);  \
    }                                                                         \
    void SET_##field(void *base, u16 data)                                    \
    {                                                                         \
        iowrite16(data, base + XFILTER2DKERNEL_CONTROL_ADDR_##field##_DATA);  \
    }

def_op_reg16(BIAS);
def_op_reg16(WIDTH);
def_op_reg16(HEIGHT);
def_op_reg16(STRIDE);

#define def_op_reg32(field)                                                   \
    u32 GET_##field(void *base)                                               \
    {                                                                         \
        return ioread32(base + XFILTER2DKERNEL_CONTROL_ADDR_##field##_DATA);  \
    }                                                                         \
    void SET_##field(void *base, u32 data)                                    \
    {                                                                         \
        iowrite32(data, base + XFILTER2DKERNEL_CONTROL_ADDR_##field##_DATA);  \
    }

def_op_reg32(FACTOR);

#define def_op_reg64(field)                                                   \
    u64 GET_##field(void *base)                                               \
    {                                                                         \
        u64 hi, lo;                                                           \
        lo = ioread32(base + XFILTER2DKERNEL_CONTROL_ADDR_##field##_DATA);    \
        hi = ioread32(base + XFILTER2DKERNEL_CONTROL_ADDR_##field##_DATA      \
                      + 4);                                                   \
        return (hi << 32) | lo;                                               \
    }                                                                         \
    void SET_##field(void *base, u64 data)                                    \
    {                                                                         \
        iowrite32((u32)data,                                                  \
                  base + XFILTER2DKERNEL_CONTROL_ADDR_##field##_DATA);        \
        iowrite32((u32)(data >> 32),                                          \
                  base + XFILTER2DKERNEL_CONTROL_ADDR_##field##_DATA + 4);    \
    }

def_op_reg64(COEFFS);
def_op_reg64(SRC);
def_op_reg64(DST);

/******************************************************************************/

struct conv_inst {
    struct platform_device *pdev;
    struct miscdevice miscdev;
    void __iomem *regs;
    struct {
        dma_addr_t pa;
        void *va;
    } image, coeff;
};

#define X2DKRNL_INSTANCE(file)                                                \
    container_of(file->private_data, struct conv_inst, miscdev)

#define IOCTL_AXICTRL_START              _IO(0, 0)
#define IOCTL_AXICTRL_ISDONE             _IO(0, 1)
#define IOCTL_AXICTRL_ISIDLE             _IO(0, 2)
#define IOCTL_AXICTRL_ISREADY            _IO(0, 3)
#define IOCTL_AXICTRL_CONTINUE           _IO(0, 4)
#define IOCTL_AXICTRL_ENABLEAUTORESTART  _IO(0, 5)
#define IOCTL_AXICTRL_DISABLEAUTORESTART _IO(0, 6)
#define IOCTL_X2DFILTER_CONFIG           _IOW(1, 0, struct x2dfilter_config)

static long x2dfilter_ioctl(struct conv_inst *krnl, unsigned int cmd,
                            struct x2dfilter_config __user *user_cfg)
{
    struct x2dfilter_config cfg;
    copy_from_user(&cfg, user_cfg, sizeof(cfg));

    switch (cmd) {
    case IOCTL_X2DFILTER_CONFIG:
        SET_FACTOR(krnl->regs, *(u32 *)&filterFactors[cfg.filter]);
        SET_BIAS(krnl->regs, filterBiases[cfg.filter]);
        SET_HEIGHT(krnl->regs, cfg.height);
        SET_WIDTH(krnl->regs, cfg.width);
        SET_STRIDE(krnl->regs, cfg.stride);

        krnl->coeff.va = (void *)filterCoeffs[cfg.filter];
        krnl->coeff.pa = dma_map_single(&krnl->pdev->dev, krnl->coeff.va,
                                        15 * 15, DMA_TO_DEVICE);
        if (krnl->coeff.pa == 0) {
            printk("x2dfilter_ioctl: dma_map_single failed\n");
            return -EINVAL;
        }
        SET_COEFFS(krnl->regs, krnl->coeff.pa);
        break;
    default:
        printk("x2dfilter_ioctl: unknown command %d\n", cmd);
        return -EINVAL;
    }

    return 0;
}

static long device_ioctl(struct file *file, unsigned int cmd,
                         unsigned long arg)
{
    struct conv_inst *krnl = X2DKRNL_INSTANCE(file);
    void *ctrl_addr        = krnl->regs + XFILTER2DKERNEL_CONTROL_ADDR_AP_CTRL;

    u32 ctrl = ioread32(ctrl_addr);

    pr_info("ap_ctrl = %08x, cmd = %x\n", ctrl, cmd);

    switch (cmd) {
    case IOCTL_AXICTRL_START:
        pr_info("src_addr = %llx\n", GET_SRC(krnl->regs));
        pr_info("dst_addr = %llx\n", GET_DST(krnl->regs));
        pr_info("coeffs_addr = %llx\n", GET_COEFFS(krnl->regs));
        pr_info("factor = %08x\n", GET_FACTOR(krnl->regs));
        pr_info("bias = %u\n", GET_BIAS(krnl->regs));
        pr_info("width = %u\n", GET_WIDTH(krnl->regs));
        pr_info("height = %u\n", GET_HEIGHT(krnl->regs));
        pr_info("stride = %u\n", GET_STRIDE(krnl->regs));

        iowrite32(ctrl | 0x1, ctrl_addr);
        return 0;
    case IOCTL_AXICTRL_ISDONE:
        return (ctrl >> 1) & 0x1;
    case IOCTL_AXICTRL_ISIDLE:
        return (ctrl >> 2) & 0x1;
    case IOCTL_AXICTRL_ISREADY:
        return !(ctrl & 0x1);
    case IOCTL_AXICTRL_CONTINUE:
        iowrite32(ctrl | 0x10, ctrl_addr);
        return 0;
    case IOCTL_AXICTRL_ENABLEAUTORESTART:
        iowrite32(ctrl | 0x80, ctrl_addr);
        return 0;
    case IOCTL_AXICTRL_DISABLEAUTORESTART:
        iowrite32(ctrl & ~0x80, ctrl_addr);
        return 0;
    case IOCTL_X2DFILTER_CONFIG:
        return x2dfilter_ioctl(krnl, cmd,
                               (struct x2dfilter_config __user *)arg);
    default:
        printk("device_ioctl: unknown command %d\n", cmd);
        return -EINVAL;
    }

    return 0;
}

static int device_mmap(struct file *file, struct vm_area_struct *vma)
{
    struct conv_inst *krnl = X2DKRNL_INSTANCE(file);
    int rc;

    if (vma->vm_end - vma->vm_start != X2DFILTER_BUFFER_SIZE) {
        pr_warn("mmap size mismatch\n");
        return -EINVAL;
    }

    rc = dma_mmap_coherent(&krnl->pdev->dev, vma, krnl->image.va,
                           krnl->image.pa, X2DFILTER_BUFFER_SIZE);
    if (rc) {
        pr_warn("dma_mmap_coherent failed\n");
        return rc;
    }

    return 0;
}

static int device_open(struct inode *inode, struct file *file)
{
    struct conv_inst *krnl = X2DKRNL_INSTANCE(file);

    /* Allocate coherent memory for AXI master usage */
    krnl->image.va = dma_alloc_coherent(
        &krnl->pdev->dev, X2DFILTER_BUFFER_SIZE, &krnl->image.pa, GFP_KERNEL);
    if (!krnl->image.va) {
        pr_err("Error allocating image buffer\n");
        return -ENOMEM;
    }

    SET_SRC(krnl->regs, krnl->image.pa);
    SET_DST(krnl->regs, krnl->image.pa + (X2DFILTER_BUFFER_SIZE >> 1));

    return 0;
}

static int device_release(struct inode *inode, struct file *file)
{
    struct conv_inst *krnl = X2DKRNL_INSTANCE(file);

    if (krnl->coeff.pa) {
        dma_unmap_single(&krnl->pdev->dev, krnl->coeff.pa, 15 * 15,
                         DMA_TO_DEVICE);
        krnl->coeff.pa = 0;
        krnl->coeff.va = 0;
    }

    if (krnl->image.pa) {
        dma_free_coherent(&krnl->pdev->dev, X2DFILTER_BUFFER_SIZE,
                          krnl->image.va, krnl->image.pa);
        krnl->image.pa = 0;
        krnl->image.va = 0;
    }

    return 0;
}

static const struct file_operations conv_fops
    = { .owner          = THIS_MODULE,
        .unlocked_ioctl = device_ioctl,
        .mmap           = device_mmap,
        .open           = device_open,
        .release        = device_release };

static int xfilter2dkernel_probe(struct platform_device *pdev)
{
    struct resource *r_mem; /* IO mem resources */
    struct device *dev   = &pdev->dev;
    struct conv_inst *lp = NULL;
    unsigned offset      = 0;
    int rc               = 0;
    dev_info(dev, "Device Tree Probing\n");

    /* Create local instance */
    lp = kzalloc(sizeof(struct conv_inst), GFP_KERNEL);
    if (!lp) {
        dev_err(dev, "Cound not allocate xfilter2dkernel device\n");
        return -ENOMEM;
    }
    dev_set_drvdata(dev, lp);
    lp->pdev = pdev;

    /* Get iospace for the device */
    r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    if (!r_mem) {
        dev_err(dev, "invalid address\n");
        return -ENODEV;
    }

    dev_info(dev, "%s start = 0x%08lx, end = 0x%08lx\n", r_mem->name,
             (uintptr_t)r_mem->start, (uintptr_t)r_mem->end);

    /* Map the device into memory */
    lp->regs = devm_ioremap_resource(dev, r_mem);
    if (IS_ERR(lp->regs)) {
        dev_err(dev, "Could not allocate iomem\n");
        rc = PTR_ERR(lp->regs);
        goto err;
    }
    dev_info(dev, "%s mapped to 0x%08lx\n", r_mem->name, (uintptr_t)lp->regs);

    /* Register misc device */
    lp->miscdev.minor = MISC_DYNAMIC_MINOR;
    lp->miscdev.name  = DRIVER_NAME;
    lp->miscdev.fops  = &conv_fops;

    rc = misc_register(&lp->miscdev);
    if (rc) {
        dev_err(dev, "Couldn't register misc device\n");
        goto err;
    }
    dev_info(dev, "Registered misc device %s (%d,%d)\n", lp->miscdev.name,
             MISC_MAJOR, lp->miscdev.minor);

    return 0;
err:
    kfree(lp);
    dev_set_drvdata(dev, NULL);
    return rc;
}

static int xfilter2dkernel_remove(struct platform_device *pdev)
{
    struct device *dev   = &pdev->dev;
    struct conv_inst *lp = dev_get_drvdata(dev);

    pr_info("Removing xfilter2dkernel\n");

    devm_iounmap(dev, lp->regs);
    misc_deregister(&lp->miscdev);
    kfree(lp);
    dev_set_drvdata(dev, NULL);
    return 0;
}

#ifdef CONFIG_OF
static struct of_device_id xfilter2dkernel_of_match[] = {
    { .compatible = "xlnx,Filter2DKernel-1.0" },
    { /* end of list */ },
};
MODULE_DEVICE_TABLE(of, xfilter2dkernel_of_match);
#else
#define xfilter2dkernel_of_match
#endif

static struct platform_driver xfilter2dkernel_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= xfilter2dkernel_of_match,
	},
	.probe		= xfilter2dkernel_probe,
	.remove		= xfilter2dkernel_remove,
};

static int __init xfilter2dkernel_init(void)
{
    printk("Hello module world.\n");
    return platform_driver_register(&xfilter2dkernel_driver);
}

static void __exit xfilter2dkernel_exit(void)
{
    platform_driver_unregister(&xfilter2dkernel_driver);
    printk(KERN_ALERT "Goodbye module world.\n");
}

module_init(xfilter2dkernel_init);
module_exit(xfilter2dkernel_exit);
